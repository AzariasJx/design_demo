# design_demo
设计模式练习demo

##策略+简单工厂+门面模式

项目需求：

接入多个支付系统进行支付

##责任链模式

项目需求：

付款完成以后，投放业务，可以在资源位置中展示当前用户的资源

要求 

1. 允许运营人员配置需要展示的资源（配置中心）
2. 资源过滤规则可变
* 过滤规则大部分可重用，但是也会有拓展和变更
* 不同资源位的过滤规则和顺序不一样
* 同一个资源由于业务阶段不同可能规则不一样
3. 允许规则实时增减和顺序调整

过滤规则：
1. 用户个人资质是否满足投放业务
2. 用户所在城市是否在业务投放城市
3. 用户近期所购买的产品是否符合业务投放人群？
4. 新用户首次购买投放指定的业务


##单例模式

在我们支付工厂的时候，我们使用了反射进行创建对象，每次调用都会通过反射获取对象会比较影响性能
所以我们使用单例模式，对工厂返回的支付策略进行优化

##状态模式+观察者模式（监听器模式）
项目需求：

订单支付完成以后，完整订单状态的流转

要求：
1. 创建订单后，订单状态初始化为待支付
2. 订单状态包括：待支付、待发货、待收货、订单完成
3. 触发订单状态变化的操作：支付订单、发货、确认收货


##装饰器模式
项目需求：

部分商品支付完成以后，更新平台币，红包发放等后续业务

要求：

1. 平台币的更新和红包发放业务为附属功能，不能影响主支付业务逻辑
2. 平台币的更新和红包发放业务只能对部分推广商品有效，且依赖于商品属性变更，如果取消平台币更新和发放红包业务
不能修改代码，要做到在线实时热变更
3. 调用层无需关心该商品是否需要更新平台币或者发放红包，做到与上层调用者完全解耦
4. 该逻辑为支付的附属业务，随着支付完成后，立即触发，但是不可影响支付的主逻辑


##享元模式

项目需求：

在大并发数据进来支付以后，发现系统频繁ygc

经过测试可知，在支付的时候，有大量的对象创建
`` PayDecorator payDecorator = new PayDecorator(new PayContext(payStrategy));``

我们准备使用享元模式优化一下

享元模式：是池技术的重要实现方式，使用共享对象可有效的支持大量细粒度的对象
* 内部状态：
    内部状态是对象可共享出来的信息，存储在享元模式内部并且不会随着环境改变
* 外部状态：
    是对象得以依赖的一个标记，随着环境改变而改变，不可以共享的状态
  

[comment]: <> (##构造者+原型模式)

[comment]: <> (项目需求：)

[comment]: <> (用户支付完成以后，部分企业或者用户需要开电子增值税发票)

[comment]: <> (要求)

[comment]: <> (1. 由于电子增值税发票所需内容比较多，而且随着国家政策可能会有所更改，发票内容的添加删除需要尽量做到灵活)

[comment]: <> (2. 发票开具不是高并发访问接口且无法缓存，尽量保证发票创建的性能·)


##模板方法模式
项目需求

公司财务、审计、法务部门需要记录用户关键核心日志、以防日后未知纠纷

要求

1. 该日志不是普通日志记录，不同的日志记录内容可能不一样
2. 可以灵活增加日志种类和处理
3. 核心日志包括：登录；订单创建、订单支付、其中订单创建需要有相关产品信息、订单支付需要有相关产品信息以及支付方式和支付金额等等
4. 日志组装完毕以后，将日志发送到queue中，会由数据处理部门进行处理